# 一、Hello world

每个C++程序都有一个main函数作为入口

```c++
#inclode <iostream>
//没有这句就需要在引用时加上std::, 指定缺省命名空间
using namespace std;
int main() {
    cout << "Hello world" << endl;
    //执行完等待操作
    system('pause');
    return 0;
}
```

# 二、注释

单行注释

`//`

多行注释

`/* */`

# 三、变量与常量

## 变量

给一段指定的内存空间起的名称

`数据类型 变量名 = 初始值;`

## 常量

用于记录程序中不可变的数据

`#define` 宏常量

`#define 常量名 常量值`

通常在文件上方定义, 表示一个常量

修饰的变量

`const 数据类型 常量名 = 常量值`

```c++
#inclode <iostream>
using namespace std;
//宏常量
#define dey 11

int main() {
    //修饰的变量
    const week = 2
    system('pause')
}
```

# 四、数据类型

## 1、整形

常用：`int 变量名 = 初始值`

| 数据类型            | 占用空间                                  | 取值范围         |
|-----------------|---------------------------------------|--------------|
| short（短整型）      | 2字节                                   | -2^15~2^15-1 |
| int（整型）         | 4字节                                   | -2^31~2^31-1 |
| long（长整型）       | win, Linux（32位）（4字节）, Linux（64位）（8字节） | -2^31~2^31-1 |
| long long（长长整型） | 8字节                                   | -2^63~2^63-1 |

## 2、`sizeof`关键字

用来统计数据类型或者变量所占空间大小

`sizeof(数据类型/变量名)`

## 3、实型（浮点型）

| 数据类型     | 占用空间 | 有效数字范围     |
|----------|------|------------|
| `float`  | 4字节  | 7位有效数字     |
| `double` | 8字节  | 15~16位有效数字 |

## 4、字符型

用于表示单个字符（C和C++中只占1个字节）

`char ch = 'a';`

## 5、转义字符

`\t \a \n` 等

## 6、字符串型

用于表示一串字符, 要用双引号

两种风格

1. ### C风格字符串

   `char 变量名[] - "字符串值"`

2. ### C++风格字符串

   `string 变量名 = "字符串值"`

## 7、布尔型

代表真或假（`true` 或 `false`）

`bool flag = true`

## 8、数据的输入

`cin >> 变量名`

```c++
#inclode <iostream>
using namespace std;
int main() {
    int a = 0;
    printf("请给变量赋值：\n")
    cin >> a;
    system("pause");
    return 0;
}
```

## 9、++与--

`a++`表示参与运算后再+1

`15 = 10 +5++`

`++a`表示先+1再参与运算

`16 = 10 + ++5`

## 10、数据类型转换

# 五、运算符

## 1、逻辑运算符

`&& 与 `    python里的 and

`|| 或`    python里的 or

> 当整数除法运算时, 如果分母为0, 异常报错
>
> 当浮点数除法运算时, 如果分母为0, 结果为`inf`（`infinite` 无穷大）
>
> 两整数相除只会保留整数部分
>
> 经行除法运算时, 在整数前面加（`float`）或（`double`）可以将类型转为浮点`(double) a1 / (float) a2;`
>
> 取模运算只能应用于整数
>
>
>
> 关系运算符号在`cout`打印时需要用括号括起来

## 2、逗号运算符

> 多个表达式合起来按照顺序执行

```c++
int a, b;
int a=1, b=2;
int a=1, b=2, cout << a << b << endl;
```

# 六、程序流程结构

## 1、选择结构

### IF语句

```c++
#inclode <iostream>

using namespace std;

int main() {
    int a = 1;
    if (a==1) {
        cout << a << endl;
    }else if (a==2){
        cout << a << endl;
    }else{
        cout << "no" << endl;
    };
    system("pause");
    return 0;
}
```

### 三目运算符

使判断更清晰明了

`表达式1 ? 表达式2 : 表达式3;`

当表达式1值为真, 则执行表达式2并返回表达式2的结果, 反之则为表达式3

### switch语句

用表达式的结果去和case后的结果做对比, 如果case后有这个结果便执行当前case下的语句, 如果没有则执行default下的语句

```c++
switch(表达式) {
    case 结果1:
        cout << '1' << endl;
        break;
    case 结果2:
        cout << '2' << endl;
        break;
    default:
        cout << '3' << endl;
        break;
}
```

## 2、循环结构

### while循环

```c++
int a = 1
while(a < 10) {
    cout << a << endl;
    a++
}
```

### do...while循环

先执行语句再判断需不需要再次执行语句

```c++
int a = 1;
do {
    cout << a <<endl;
    a++;
} while (a < 10)
```

### for循环

```c++
for(int i = 0; i < 10; i++){
    cout << i << endl;
}
```

## 3、跳转语句

### break语句

用于跳出循环体或循环结构（结束循环）

### continue语句

用于跳过本次循环, 本次循环continue下面的代码不会执行

### goto语句

无条件跳转代码, 一般标记名称用全大写来表示

```c++
int main() {
    cout << 'a' << endl;
    goto FLAG;
    cout << 'b' << endl;
    cout << 'c' << endl;
    FLAG:
    cout << 'd' << endl;
    cout << 'e' << endl;
}
```

# 七、数组

一个集合, 里面存放了相同类型的元素

## 1、一维数组

- `数据类型 数组名[数组长度]`

- `数据类型 数组名[数组长度] = {值1, 值2...}`

  当后面的值数量不足数组长度时, 会自动用0补齐

- `数据类型 数组名[] = {值1, 值2, 值3}`

  此时数组长度为初始值个数

  `数组长度 = sizeof(数组名) / sizeof(数据类型)`

### 清空数组

> memset函数可以把数组中全部的元素清0（只适用于C++基础数据类型）
>
> 注意：在Linux环境下, 使用memset函数需要包含头文件`# include <string.h>`

```C++
memset(users, 0, sizeof(users));
```

### 复制数组

> memcpy函数可以把数组中的全部元素复制到一个相同大小的数组（只适用于C++基本数据类型）
>
> 注意：在Linux环境下, 使用memcpy函数需要包含头文件`# include <string.h>`

```C++
int main() {
    int users[3] = {1, 2, 3};
    int users2[sizeof(users) / sizeof(int)];

    memcpy(users2, users, sizeof(users));
    
    for (int i = 0; i < 3; i++) {
        cout << users2[i] << endl;
    }
}
```

### 一维数组和指针

> 将一个整型变量加1后, 其至将增加1
>
> 将指针变量的地址加1后, 增加的量大于数组指向的数据类型所占用的字节数

### 数组的地址

> 数组在内存空间中占用的空间是连续的
>
> C++将数组的地址解释为数组第0个元素的地址
>
> 数组第0个元素的地址和数组首位地址的取值是相同的
>
> 数组第n个元素的地址是：`数组首地址 + n`
>
> C++编译器把`数组名[下标]`解释为`*(数组首地址 + 下标)`

### 数组的本质

> 数组是占用连续空间的一块内存, 数组名被解释为数组第0个元素的地址
>
> C++操作这块内存有两种方法：数组解释法和指针表示法, 他们是等价的

### 数组名不一定会被解释为地址

> 在多少情况下, C++将数组名解释为数组的第0个元素的地址, 但是, 将`sizeof`运算符用于数据名是将返回占用内存空间的字节数
>
> 可以修改指针的值, 但数组名是常量, 不可修改

### 一维数组的越界

> 索引超出数组大小, 形成野指针

### 一维数组用于函数的参数

1. 指针的数组表示

   > C++内部, 用指针来处理数组
   >
   > C++编译器把    `数组名[下标]`    解释为    `*(数组首地址+下标)`
   >
   > C++编译器把    `地址[下标]`    解释为    `*(地址+下标)`

2. 用于函数的参数

   > 一维数组用于函数的参数时, 只能传递数组的地址, 并且必须把数组长度也传进去, 除非数组最后一个元素有标记

   ```	C++
   void show(int* p, int len){
       cout << len << endl;
   }
   
   void show2(int p[], int len){}
   
   int main() {
       int a[] = {1, 2, 3};
       cout<< typeid(a).name() << " >> " << sizeof(typeof(a)) /sizeof(int)  << endl;
       show(a, (int)(sizeof(a) / sizeof(int)));
   }
   ```

### 使用new动态创建数组

普通数组在栈上分配内存, 栈很小；如果需要存放更多的元素, 必须在堆上分配内存。

动态创建一维数组的语法：`数据类型 *指针 = new 数据类型[数组长度];`

释放一维数组的语法：`delete [] 指针`

注意：

- 动态创建的数组没有数组名, 所以不可以使用 `sizeof` 关键字
- 可以用数组表示法和指针表示法两种方式使用动态数组
- 必须使用 `delete []` 来释放动态数组的内存, 不能只用`delete`（只会释放首元素的空间所以需要[]）
- 不要使用 `delete []` 来释放不是`new []`分配的内存
- 对空指针使用 `delete []` 是安全的, 释放内存后, 应该把指针置空 `nullptr`
- 声明普通数组的时候, 数组长度可以使用变量, 相当于在栈是动态创建数组, 并且补需要释放
- 如果内存不足, 调用 `new` 方法会产生异常, 导致程序中止；如果在`new`关键字后面加上`(std::nothrow)`选项, 则返回`nullptr`,
  不会产生异常。
- 使用 `delete []` 释放数组时, 不需要指定数组大小, 系统会自动跟踪已分配的数组的内存
- 不要用 `delete []` 释放同一块内存块2次, 否则等同于野指针

### 数组的排序

`qsort()`函数用于对各种数据类型的数组进行排序

```C++
// 如果函数的返回值<0, 那么p1所指向元素会被排在p2所指向元素的前面。
// 如果函数的返回值==0, 那么p1所指向元素与p2所指向元素的顺序不确定。
// 如果函数的返回值>0, 那么p1所指向元素会被排在p2所指向元素的后面。
int sr(const void *p1, const void *p2) {
    return (*(int *) p1) - (*(int *) p2);
}


int main() {
    int a[8] = {7, 4, 2, 5, 0, 3, 1, 9};

    qsort(a, sizeof(a) / sizeof(int), sizeof(int), sr);

    for (int i = 0; i < sizeof(a) / sizeof(int); ++i) {
        cout << a[i] << endl;
    }
}
```

`void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, int (*)(const void *,const void *) _PtFuncCompare)`

`qsort()`函数的其它细节

- 形参中的地址用`void`是为了支持任意数据类型, 在回调函数中必须具体化
- `size_t`是C标准库中定义的, 在64位系统中8字节无符号整型(`unsigned long long`) `typedef unsigned long long size_t`
- 排序的需求除了升序和降序, 还有横夺不可预知的情况, 只能使用回调函数

### 数组的查找(二分查找)

> 每次取前后指针和的一半取出来的值大于要查询值时, 那么后指针向半值前移一位, 否则前指针向半值后移一位

```C++	
int search(const int arr[], int len, int key) {
    int low = 0, high = len - 1, mid;
    while (low <= high) {
        mid = (low + high) / 2;
        if (arr[mid] == key) return mid;
        else if (arr[mid] > key) high = mid - 1;
        else low = mid + 1;
    }
    return -1;
}
```

### C风格字符串

- `string`使用方便, 能自动拓展, 不用担心内存问题
- `string`是C++的类, 封装了C风格的字符串
- 某些场景中, C风格字符串更方便、更高效

C语言约定：如果字符型(`char`)数组的末尾包含了空字符`\0`(也就是0), 那么该数组中的内容就是一个字符串

因为字符串需要用0结尾, 所以声明字符数组的时候, 要预留多一个字节来存放0

#### 初始化

```	C++
char name1[11]; // 可以存放10个字符, 没有初始值, 全是垃圾值；
    char name2[11] = "hello";   // 初始化内容, 系统会自动添加0
    char name3[] = {"hello"};   // 初始化内容, 系统会自动添加0, 数组长度为6
    char name4[11] = {"hello"}; // 初始化内容, 系统会自动添加0
    char name5[11] {"hello"};   // 初始化内容, 系统会自动添加0。C++11标准
    char name6[11] = {0};   // 把全部的元素初始化为0
```

#### 清空字符串(`memset`)

```C++
memset(name, 0, sizeof(name));	// 全部设置为0

name[0] = 0	// 不推荐
```

#### 字符串复制或赋值(`strcpy`)

将参赛src的字符串拷贝到参数dest所指的地址, 并返回参数dest的字符串起始位置, 复制完字符串后, 会在dest后追加0,
如果参数dest所指定的内存空间不够大, 会导致数组越界。

```C++
char name[11] = "hello";
char test[11];
strcpy(test, name)
```

#### 字符串复制或赋值(`strncpy`)

把src前n个字符的内容复制到dest中, 并返回dest字符串起始位置, 如果src字符串长度小于n, 则拷贝完字符串后, 在dest后面追加0,
直到n个。如果src的长度大于大于n, 就截取src的前n个字符, 不会在dest后追加0 。如果参数dest所指定的内存空间不够大, 会导致数组越界。

```C++
char name[11] = "hello";
char test[11];
strncpy(test, name, 3)
```

#### 获取字符串长度(`strlen`)

计算字符串有效长度不包含0

`size_t strlen(const char *str)`

#### 字符串拼接(`strcat`)

把src字符串内容添加到dest字符串的后面, 并返回dest字符串的起始地址

`char *strcat(char *dest, char *src)`

#### 字符串拼接(`strncat`)

把src字符串内容的前n项添加到字符串的后面, 并返回dest字符串的起始地址

`char *strncat(char *dest, char *src, const size_t n)`

#### 字符串比较`strcmp()`和`strncmp()`

比较str1和str2的大小, 相同返回0, str1大于str2返回1, str1小于str2返回-1

`int strcmp(const char *str1, const char *str2)`

比较str1和str2的前n个字符大小, 相同返回0, str1大于str2返回1, str1小于str2返回-1

`int strcmp(const char *str1, const char *str2, const size_t n)`

两个字符串比较方法是比较字符的ASCNII码的大小, 从两个字符串的第一个字符开始, 如果分不出大小, 那就比较第二个

#### 字符查找strchr()和strrchr()

返回一个指向字符串s中第一个出现c的位置, 如果找不到返回0

`char *strchr(const char *s, const int c)`

#### 字符串查找strstr()

检索子串在字符串中首次出现的位置, 返回字符串str中第一次出现子串substr的地址例如个没有则返回0

`char *strstr(const char *str, const char * substr)`

#### 注意事项

字符串的结尾标志是0, 按照约定, 在处理字符串的时候, 会从起始位置开始搜索0, 一直找下去, 找到为止（不会判断数组是否越界）

结尾标志0后面的都是垃圾内容

字符串每次使用之前都要初始化, 减少入坑的可能

不在子函数中对字符指针使用sizeof运算

## 2、二维数组

数据是连续的与一维数组一致

- `数据类型 数组名[行数][列数];`

- `数据类型 数组名[行数][列数] = {{值1, 值2},{值3, 值4}}`

  简单明了

- `数据类型 数组名[行数][列数] = {值1, 值2, 值3};`

  给定行数和列数他能自动把{}里的变为一个矩阵

- `数据类型 数组名[][列数] = {值1, 值2, 值3}`

# 八、函数

`返回值类型 函数名 （数据列表） {函数体}`

```c++
//声明一个函数（让函数可以在使用的后面定义）, 可以声明多次但是只能定义一次
int abb (int a);

//定义函数	void（无类型）代表函数不需要返回值
void add (int a, int b) {
    
}
```

# 九、C++分文件编写

app.cpp

```c++
//
// Created by 22143 on 2022/10/8.
//
#include <iostream>
#include <string>
#include "swap.h"

using namespace std;


int main() {
    int a = swap(1, 2);
    cout << a << endl;

    system("pause");
    return 0;
}
```

swap.h

```c++
//
// Created by 22143 on 2022/10/15.
//
#include <iostream>

using namespace std;

int swap (int a, int b);
```

swap.cpp

```c++
//
// Created by 22143 on 2022/10/15.
//

#include "swap.h"

int swap (int a, int b) {
    return a+b;
}
```

# 类型别名

```c++
typedef 
```

# 十、指针

指针：指向一块内存（记录地址编号）

## 1、定义指针

`数据类型 * 指针变量名;`

`int * p`

## 2、常量指针

```c++

void test(const int *p) {
    cout << *p << endl;
}

int main() {
    int a = 3, b = 10;
    const int *pa = &a;
    # 可以修改指针的指向, 但是不能解应勇修改值 *pa = 12
    pa = &b;
    test(pa);
    cout << a << '\n' << pa << '\n' << *pa << endl;
}
```

> 不能通过解引用的方法修改内存中的值(用原始的变量名可以修改)

## 3、指针常量

```c++
int main() {
    int a = 3, b = 10;
    int* const pa = &a;
    *pa = 12;
    # 不可以修改指针指向 pa = &b;
    cout << *pa << endl;
}
```

## 4、常指针常量

```c++
int main() {
    int a = 3, b = 10;
    const int* const pa = &a;
}
```

## 5、void关键字

```c++
void func(void *p) {
    // void * 可以接收任意类型的指针
    cout << p << endl;
}
```

## 6、二级指针

> 指针是指针变量的简称, 也是变量, 是变量就有地址。
>
> 指针用于存放普通变量地址
>
> 二级指针用于存放指针变量的地址

语法：`数据类型 **指针名`

```c++
int i = 8;
int *pi = &i;
int **ppi = &pi;
cout << i << '\n' << pi << '\n' << ppi << '\n' << *pi << '\n' << **ppi << endl;
```

使用指针的目的：

1. 传递地址
2. 存放动态分配的内存地址

在函数中, 如果传递平台变量的地址, 形参用指针；传递指针的地址, 形参用二级指针

把普通变量的地址传入函数后可以在函数中修改变量的值；把指针地址传入函数后可以在函数中修改指针的值

## 7、空指针

在C和C++中, 用0或NULL都可以表示空指针

声明后, 在赋值之前, 可以让它指向空, 表示没有指向任何地址



> 使用空指针的后果：
>
> 	如果对空指针解引用, 程序会崩溃
>
> 	如果对空指针使用`delete`运算符, 系统将会忽略该操作, 不会出现异常, 所以内存释放后, 也应该把指针指向空



在函数中需要判断形参是不是空指针的代码, 保证函数的健壮性

> C++ 11的nullptr
>
> 	用0和NULL表示空指针会产生歧义, C++11中建议用nullptr表示空指针, 也就是(void *)0
>
> 注意：在Linux平台线下, 如果要使用nullptr, 编译时需要加`-std=c++11`

## 8、野指针

野指针就是指针指向的地址不是有效的地址

在程序中, 如果访问野指针, **可能**会造成程序崩溃

> 出现野指针的情况：
>
> 1. 指针在定义的时候没有进行初始化, 它的值是不确定的。
> 2. 如果用指针指向动态分配的内存, 内存被释放后, 指针不会置空, 但是, 指向的地址已经失效。
> 3. 指针指向的变量已超越变量作用域（变量的内存空间已被系统回收）
>
> 规避方法：
>
> 1. 指针在定义的时候, 如果没地方指, 就初始化为`nullptr`
> 2. 动态分配都内存被释放后将其置为`nullptr`
> 3. 函数不要返回局部变量的地址

野指针的危害比空指针要大的多, 在程序中, 如果访问野指针, 可能会造成程序崩溃。是可能不是一定, 程序的表现是不稳定, 增加了调试难度

## 9、函数指针

函数都二进制代码存放在内存四区的代码段, 函数的地址是它在内存中的起始地址, 如果把函数的地址作为参数传递给函数,
就可以在函数中灵活的调用其它函数

> 函数指针的三个步骤：
>
> 1. 声明函数指针
> 2. 让函数指针指向函数的地址
> 3. 通过函数指针调用

1. 声明函数指针

   > 声明普通指针时, 必须提供指针的类型, 同样, 声明函数指针时, 也必须提供函数类型, 函数类型指的是返回值和参数列表

   ```C++
   #include <iostream>
   
   // 指定缺省的命名空间
   using namespace std;
   
   // 宏常量
   #define PI 3.1415926
   
   void func(int age, string name) {
       cout << "age=" << age << "name=" << name << endl;
   }
   
   void show(void (*ptf)(int, string)) {
       ptf(1, "test");
       (*ptf)(1, "test");
   }
   
   int main() {
       show(func);
   }
   
   ```


2.

# 十一、C++内存模型

## 1、堆和栈的区别

1. 管理方式不同

   > 栈是系统自动管理的, 在出作用域时将被自动释放；
   >
   > 堆需要手动释放, 若不释放则由系统在程序结束时回收

2. 空间大小不同

   > 堆内存的大小受限于物理内存空间；
   >
   > 而栈就很小, 一般只有8MB（可以修改系统参数）

3. 分配方式不同

   > 堆是动态分配
   >
   > 栈有静态分配和动态分配（都是自动释放）

4. 分配效率不同

   > 是系统提供的数据结构, 计算机在底层提供了对栈的支持, 进栈和出栈有专门的指令, 效率比较高；
   >
   > 堆是由C++函数库提供的。

5. 是否产生碎片

   > 对于栈来说, 进栈和出栈都有着严格的顺序（先进后出）, 不会产生碎片；
   >
   > 而堆频繁的分配和释放, 会造成内存空间的不连续, 容易产生碎片, 太多的碎片会导致性能的下降

6. 增长方向不同

   > 栈向下增长, 以降序分配内存地址；
   >
   > 堆向上增长, 以升序分配内存地址。

## 2、动态分配内存

1. 声明一个指针
2. 用new运算符向系统申请一块内存, 让指针指向这块内存
3. 通过对指针解引用的方法, 像使用变量一样使用这块内存
4. 如果这块内存不用了, 用delete运算符释放它。

> 申请内存的语法：
>
> `new 数据类型(初始值);//C++11支持0`
>
> 如果申请成功, 返回一个地址；
>
> 如果申请失败, 返回一个空地址（暂时不考虑失败的情况）
>
> 释放内存的语法：`delete 地址;`

- 动态分配出来的内存没有变量名, 只能通过指向它的指针来操作内存中的数据。
- 如果动态分配的内存不用了, 必须用`delete`释放它, 否则有可能用尽系统的内存。
- 动态分配的内存生命周期与程序相同, 程序退出时, 如果没有释放, 系统将自动回收。
- 就算指针的作用域已失效, 所指向的内存也不会释放。个用指针跟踪已分配的内存时, 不能跟丢。↑

